# 接口文档

- **接口地址**: `http://<服务器IP>:8000/match`
- **请求方式**: `POST`
- **数据格式**: `application/json`

## 请求参数示例

前端需要把所有参与者的信息打包成一个数组发送过来。
**注意**：`gift_description` 直接传用户填写的长文本，`quiz_data` 传题目和选项的完整文字。

```json
[
  {
    "id": "user_01",
    "name": "钢铁侠",
    "email": "tony@stark.com",
    "wechat": "iron_man",
    "mbti": "ENTP",
    "gift_description": "我做了一个方舟反应堆模型，会发蓝光，虽然不能发电但摆在桌上非常赛博朋克。",
    "quiz_data": [
      {
        "question_text": "出门参加圣诞派对，你会选择哪条围巾搭配？",
        "selected_option": "D. 黑色机能风防风面罩围脖"
      },
      {
        "question_text": "周末一般怎么过？",
        "selected_option": "B. 在实验室搞科研"
      }
    ]
  },
  {
    "id": "user_02",
    "name": "美队",
    "email": "steve@usa.com",
    "wechat": "cap_america",
    "mbti": "ISFJ",
    "gift_description": "一本二战时期的素描本复刻版，包含一套专业绘画铅笔。",
    "quiz_data": [
      {
        "question_text": "出门参加圣诞派对，你会选择哪条围巾搭配？",
        "selected_option": "A. 纯灰色的羊绒围巾"
      },
      {
        "question_text": "周末一般怎么过？",
        "selected_option": "C. 去看画展"
      }
    ]
  }
]
```

## 返回结果示例

后端会返回一个排好序的链表 (`chain`)，前端按顺序展示即可。
`match_reason` 是 AI 结合性格和礼物生成的推荐理由。

```json
{
  "chain": [
    {
      "giver_name": "钢铁侠",
      "giver_wechat": "iron_man",
      "receiver_name": "美队",
      "receiver_wechat": "cap_america",
      "gift_summary": "方舟反应堆模型",
      "match_reason": "虽然美队喜好复古，但AI分析认为该模型具有极高的收藏价值..."
    },
    {
      "giver_name": "美队",
      "giver_wechat": "cap_america",
      "receiver_name": "钢铁侠",
      "receiver_wechat": "iron_man",
      "gift_summary": "素描本复刻版",
      "match_reason": "托尼其实内心细腻，素描本能帮助他记录灵感..."
    }
  ],
  "total_participants": 2
}
```

---

## 环境依赖

请确保安装 Python 3.8+，并安装以下库：

```bash
pip install fastapi uvicorn openai pydantic python-dotenv
```

## 启动服务

在根目录下运行：

```bash
python run.py
```

启动后：

- 接口地址: `http://localhost:8000/match`
- 在线文档: `http://localhost:8000/docs`

---

# 技术流程详解

> 利用 **大语言模型** 进行非结构化数据的特征提取与情感计算，结合 **自适应混合模因算法 (Memetic Algorithm)** 解决带约束的组合优化问题，最终输出全局满意度最优的环形赠送链条。

## 1. 数据预处理与上下文构建

**挑战**：用户输入包含大量的非结构化文本（如几百字的礼物描述）和离散的标签数据（MBTI、问卷选项）。
**处理逻辑**：

- **格式化**：将分散的问卷选项拼接为语义连贯的字符串（如 `问:周末安排 -> 答:独自在家`）。
- **提示词构建**：构建结构化提示词，定义 AI 的角色（心理分析师）和任务边界（提取特征、计算匹配分）。

## 2. AI 语义推理与特征量化

这是系统的核心智能化环节。我们不依赖传统的关键词匹配，而是进行深层的**意图识别**。

- **输入**：
  - **人物画像**：性格特征 + 行为偏好。
  - **物品画像**：自然语言描述的物品。
- **推理过程**：
  1.  **实体抽取**：从冗长的描述中提取核心物品（如 `“一个粉色毛绒玩具”`）。
  2.  **偏好映射**：分析人物的潜在需求（如 `INTJ + 独处` $\rightarrow$ 偏好 `实用/科技/阅读类`）。
  3.  **相容性计算**：评估物品对该人物的吸引力，输出 $0-100$ 的量化分数。
- **输出**：一个二维矩阵，记录了任意两人之间礼物赠送的满意度分数。

> **示例数据结构 (评分矩阵)**：
>
> ```json
> [
>   { "receiver": "A", "giver": "B", "score": 85, "reason": "符合极简审美..." },
>   { "receiver": "A", "giver": "C", "score": 30, "reason": "风格过于花哨..." }
> ]
> ```

## 3. 组合优化求解

**数学问题**：将礼物交换建模为 **TSP (旅行商问题)** 的变种——寻找最大权值哈密顿回路。

**算法选型：自适应混合模因算法 (Adaptive Memetic Algorithm)**
为了在有限时间内兼顾“全局搜索”与“局部收敛”，我们采用了**进化计算**架构。该算法被誉为“遗传算法的加强版”，核心在于引入了**拉马克进化论**思想（即子代在继承基因后，会进行自我学习改良）。

- **核心算子设计**：
  1.  **混合初始化**：种群并非纯随机生成，而是引入部分经过预优化的个体，提升进化起点。
  2.  **顺序交叉 (Order Crossover, OX1)**：
      - _技术细节_：为了解决环形排列的合法性问题（防止出现重复或遗漏的人），采用了 OX1 算子。它能保留父代优秀的相对顺序片段，保证生成的子代绝对合法。
  3.  **强力局部改良 (Education Phase)**：
      - _核心亮点_：这是模因算法的灵魂。每生成一个子代，立即对其执行 **2-Opt (两元素交换)** 局部搜索。这意味着每个“孩子”在进入下一代之前，都经过了“特训”，迅速收敛到局部最优。
  4.  **动态逃逸 (Catfish Effect)**：
      - _机制_：监控种群的进化停滞期。一旦连续 15 代最优解无提升，算法自动淘汰种群中末尾 30% 的劣质个体，注入全新的随机个体。这利用“鲶鱼效应”搅动种群，强制跳出局部极值陷阱。

---

# 数据流转示例

为了更直观地理解系统内部运作，我们以 3 位用户为例，追踪数据从输入到输出的完整形态变化。

**参与者设定**：

- **User A (钢铁侠, ENTP)**：送微型反应堆（科技/酷炫）。
- **User B (美队, ISFJ)**：送素描本（复古/文艺）。
- **User C (蜘蛛侠, INFP)**：送乐高积木（趣味/拼搭）。

### 阶段 1: 原始输入 (Raw Input)

前端发送的标准 JSON 请求：

```json
[
  {
    "id": "user_a",
    "name": "钢铁侠",
    "mbti": "ENTP",
    "gift_description": "微型方舟反应堆模型，赛博朋克风格...",
    "quiz_data": [...]
  },
  {
    "id": "user_b",
    "name": "美队",
    "mbti": "ISFJ",
    "gift_description": "二战复古素描本...",
    "quiz_data": [...]
  },
  {
    "id": "user_c",
    "name": "蜘蛛侠",
    "mbti": "INFP",
    "gift_description": "星球大战限定乐高...",
    "quiz_data": [...]
  }
]
```

### 阶段 2: AI 语义推理与打分 (The Matrix)

AI 分析了每个人的性格和每份礼物的特征，计算出了**所有可能的赠送组合**的满意度分数。

**可视化评分矩阵**：
_(行代表收礼者，列代表送礼者)_

| (收) \ (送)         | 🎁 A 的反应堆 | 🎁 B 的素描本 |   🎁 C 的乐高   |
| :------------------ | :-----------: | :-----------: | :-------------: |
| **User A (钢铁侠)** |   0 (自己)    |  30 (太老旧)  | **95 (爱折腾)** |
| **User B (美队)**   |  40 (太前卫)  |   0 (自己)    |  60 (有点意思)  |
| **User C (蜘蛛侠)** | **90 (超酷)** |  50 (还可以)  |    0 (自己)     |

**系统内部生成的 JSON 数据** (传递给算法模块)：

```json
[
  {
    "receiver_id": "user_a",
    "gift_from_id": "user_b",
    "score": 30,
    "reason": "风格不符..."
  },
  {
    "receiver_id": "user_a",
    "gift_from_id": "user_c",
    "score": 95,
    "reason": "乐高符合ENTP的创造欲..."
  },
  {
    "receiver_id": "user_b",
    "gift_from_id": "user_a",
    "score": 40,
    "reason": "科技感太强，不实用..."
  },
  {
    "receiver_id": "user_b",
    "gift_from_id": "user_c",
    "score": 60,
    "reason": "休闲解压..."
  },
  {
    "receiver_id": "user_c",
    "gift_from_id": "user_a",
    "score": 90,
    "reason": "完全击中审美..."
  },
  {
    "receiver_id": "user_c",
    "gift_from_id": "user_b",
    "score": 50,
    "reason": "中规中矩..."
  }
]
```

### 阶段 3: 算法求解与最终链表 (The Output)

**算法决策逻辑**：
算法需要在上述矩阵中找到一个闭环，使得总分最高。

- **路径 1**: A->B->C->A (总分: 40 + 50 + 95 = 185)
- **路径 2**: A->C->B->A (总分: 90 + 60 + 30 = 180)

**最终选择路径 1 (A送B, B送C, C送A)**，因为总满意度最高。前端收到的结果：

```json
{
  "chain": [
    {
      "giver_name": "钢铁侠",
      "receiver_name": "美队",
      "gift_summary": "微型反应堆",
      "match_reason": "虽然风格不同，但AI认为这对美队来说是一种新奇的体验..."
    },
    {
      "giver_name": "美队",
      "receiver_name": "蜘蛛侠",
      "gift_summary": "复古素描本",
      "match_reason": "INFP 喜欢文艺和表达，素描本非常适合记录灵感..."
    },
    {
      "giver_name": "蜘蛛侠",
      "receiver_name": "钢铁侠",
      "gift_summary": "限定乐高",
      "match_reason": "乐高的拼搭属性完美契合 ENTP 爱折腾的性格，这是全场最佳匹配！"
    }
  ],
  "total_participants": 3
}
```

---

## 鲁棒性与边界处理

为了保证系统在实际生产环境中的稳定性，构建了多级熔断机制：

1.  **零权矩阵自适应**：
    - 当 AI 服务不可用（返回空数据或超时）时，系统会自动构建一个**全零权重矩阵**。
    - 此时算法自动退化为“随机闭环生成器”。由于 OX1 交叉算子的特性，算法依然能保证生成一个**合法、不断链、不重复**的 A->B->C->A 闭环，保证流程畅通。
2.  **自送自收物理屏蔽**：
    - 在矩阵构建层，强制将 $W_{ii}$ (自己对自己) 的权重设为 0（逻辑屏蔽），并在算法层通过排列约束（物理屏蔽）双重确保用户绝对不会抽到自己的礼物。
3.  **兜底文案生成**：
    - 当检测到 AI 未返回推荐理由时，后端会自动截取用户原始描述生成摘要，并填充兜底文案（如“系统随机匹配”），确保前端 UI 不会出现空窗。
