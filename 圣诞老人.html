<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 粒子聖誕老人 - 超大禮物盒版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Noto Sans TC', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            font-size: 14px;
            z-index: 10;
        }
    </style>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="info">
        聖誕快樂！<br>
        3D 粒子聖誕老人 (超大禮物盒版)
    </div>
    <div id="canvas-container"></div>

    <script>
        // --- 全局變量 ---
        let scene, camera, renderer;
        let snowSystem, santaGroup, trailSystem;
        let reindeerLegs = []; 
        let clock = new THREE.Clock();

        let width = window.innerWidth;
        let height = window.innerHeight;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000510, 0.002);

            camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
            camera.position.set(0, 20, 150);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.setClearColor(0x000510);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createSnow();
            createSantaTeam();
            createGround();

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const count = 6000;

            for (let i = 0; i < count; i++) {
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 1000 - 500;
                const z = Math.random() * 2000 - 1000;
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 4,
                map: getTexture(),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        function createSantaTeam() {
            santaGroup = new THREE.Group();
            const particleTexture = getTexture();
            const sleighGeo = new THREE.BufferGeometry();
            const sleighPos = [];
            const sleighColors = [];
            
            const addParticlesInBox = (count, bounds, colorObj) => {
                const c = new THREE.Color(colorObj);
                for(let i=0; i<count; i++) {
                    const x = bounds.x + (Math.random() - 0.5) * bounds.w;
                    const y = bounds.y + (Math.random() - 0.5) * bounds.h;
                    const z = bounds.z + (Math.random() - 0.5) * bounds.d;
                    sleighPos.push(x, y, z);
                    sleighColors.push(c.r, c.g, c.b);
                }
            };

            // 1. 雪橇 (Sleigh)
            addParticlesInBox(3000, {x: 0, y: 0, z: 0, w: 25, h: 10, d: 15}, 0xff0000);
            addParticlesInBox(600, {x: 0, y: -6, z: 6, w: 30, h: 2, d: 2}, 0xffd700);
            addParticlesInBox(600, {x: 0, y: -6, z: -6, w: 30, h: 2, d: 2}, 0xffd700);

            // 2. 聖誕老人 (Santa)
            addParticlesInBox(1500, {x: -2, y: 8, z: 0, w: 10, h: 12, d: 10}, 0xff0000);
            addParticlesInBox(500, {x: -2, y: 16, z: 0, w: 6, h: 6, d: 6}, 0xffcccc);
            addParticlesInBox(600, {x: 2, y: 15, z: 0, w: 4, h: 6, d: 6}, 0xffffff);
            addParticlesInBox(500, {x: -3, y: 20, z: 0, w: 8, h: 4, d: 6}, 0xff0000);
            
            // 3. 超大禮物箱 (Extra Large Gift Box) - 後座
            // 位置稍微往後移(-16) 並加高中心點(9)
            const boxCenter = {x: -16, y: 9, z: 0};
            
            // 白色箱體 - 尺寸加大到 18x18x18 (原 12x12x12)
            addParticlesInBox(3000, {x: boxCenter.x, y: boxCenter.y, z: boxCenter.z, w: 18, h: 18, d: 18}, 0xffffff);
            
            // 紅色絲帶 - 縱向 (寬度和高度隨箱子增加)
            addParticlesInBox(600, {x: boxCenter.x, y: boxCenter.y, z: boxCenter.z, w: 19, h: 19, d: 3}, 0xff0000);
            // 紅色絲帶 - 橫向
            addParticlesInBox(600, {x: boxCenter.x, y: boxCenter.y, z: boxCenter.z, w: 3, h: 19, d: 19}, 0xff0000);
            
            // 紅色蝴蝶結 (頂部) - 位置提高
            const bowY = boxCenter.y + 10; // 頂部位置 (9 + 9 + 1)
            // 左圈 (加大)
            addParticlesInBox(300, {x: boxCenter.x, y: bowY, z: -3, w: 4, h: 7, d: 3}, 0xff0000);
            // 右圈 (加大)
            addParticlesInBox(300, {x: boxCenter.x, y: bowY, z: 3, w: 4, h: 7, d: 3}, 0xff0000);
            // 中間結
            addParticlesInBox(150, {x: boxCenter.x, y: bowY - 1, z: 0, w: 3, h: 3, d: 3}, 0xff0000);


            // 4. 馴鹿身體與頭部
            const createReindeerBody = (offsetX, offsetZ) => {
                // 身體
                addParticlesInBox(800, {x: offsetX, y: 0, z: offsetZ, w: 15, h: 8, d: 6}, 0x8b5a2b);
                // 頭
                addParticlesInBox(400, {x: offsetX + 8, y: 6, z: offsetZ, w: 6, h: 6, d: 5}, 0x8b5a2b);
                
                // 紅鼻子
                addParticlesInBox(100, {x: offsetX + 11, y: 6, z: offsetZ, w: 2, h: 2, d: 2}, 0xff0000);

                // 鹿角
                const antlerColor = 0xf0e68c; 
                addParticlesInBox(60, {x: offsetX + 6, y: 11, z: offsetZ - 2, w: 2, h: 8, d: 1}, antlerColor);
                addParticlesInBox(30, {x: offsetX + 8, y: 10, z: offsetZ - 2, w: 4, h: 1, d: 1}, antlerColor);
                addParticlesInBox(30, {x: offsetX + 5, y: 13, z: offsetZ - 2, w: 3, h: 3, d: 1}, antlerColor);
                addParticlesInBox(60, {x: offsetX + 6, y: 11, z: offsetZ + 2, w: 2, h: 8, d: 1}, antlerColor);
                addParticlesInBox(30, {x: offsetX + 8, y: 10, z: offsetZ + 2, w: 4, h: 1, d: 1}, antlerColor);
                addParticlesInBox(30, {x: offsetX + 5, y: 13, z: offsetZ + 2, w: 3, h: 3, d: 1}, antlerColor);
            };

            createReindeerBody(40, 6);
            createReindeerBody(40, -6);
            createReindeerBody(70, 6);
            createReindeerBody(70, -6);

            // 韁繩
            addParticlesInBox(500, {x: 35, y: 2, z: 0, w: 50, h: 1, d: 14}, 0xffffaa);

            // --- 構建靜態物體 Mesh ---
            sleighGeo.setAttribute('position', new THREE.Float32BufferAttribute(sleighPos, 3));
            sleighGeo.setAttribute('color', new THREE.Float32BufferAttribute(sleighColors, 3));
            const sleighMat = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                map: particleTexture,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const sleighSystem = new THREE.Points(sleighGeo, sleighMat);
            santaGroup.add(sleighSystem);


            // --- 5. 馴鹿腿部 (動態) ---
            const createLeg = (baseX, baseY, baseZ, phaseOffset) => {
                const legGroup = new THREE.Group();
                legGroup.position.set(baseX, baseY, baseZ); 

                const legGeo = new THREE.BufferGeometry();
                const legPos = [];
                for(let i=0; i<200; i++) { 
                    const x = (Math.random() - 0.5) * 2;
                    const y = (Math.random() * -6);
                    const z = (Math.random() - 0.5) * 2;
                    legPos.push(x, y, z);
                }
                legGeo.setAttribute('position', new THREE.Float32BufferAttribute(legPos, 3));
                
                const legMat = new THREE.PointsMaterial({
                    color: 0x8b5a2b, 
                    size: 1.5,
                    map: particleTexture,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const legPoints = new THREE.Points(legGeo, legMat);
                legGroup.add(legPoints);
                santaGroup.add(legGroup);

                reindeerLegs.push({
                    mesh: legGroup,
                    phase: phaseOffset
                });
            };

            const addLegsForReindeer = (rx, rz) => {
                createLeg(rx + 5, -3, rz - 2, 0); 
                createLeg(rx + 5, -3, rz + 2, Math.PI); 
                createLeg(rx - 5, -3, rz - 2, Math.PI); 
                createLeg(rx - 5, -3, rz + 2, 0); 
            };

            addLegsForReindeer(40, 6);
            addLegsForReindeer(40, -6);
            addLegsForReindeer(70, 6);
            addLegsForReindeer(70, -6);


            // 6. 魔法拖尾
            const trailGeo = new THREE.BufferGeometry();
            const trailPos = [];
            const trailCount = 1500; 
            for(let i=0; i<trailCount; i++) trailPos.push(0, -1000, 0); 
            trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(trailPos, 3));
            
            const trailMat = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 2,
                map: particleTexture,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            trailSystem = new THREE.Points(trailGeo, trailMat);
            
            trailSystem.userData = {
                particles: [], 
                spawnTimer: 0
            };
            
            for(let i=0; i<trailCount; i++) {
                trailSystem.userData.particles.push({
                    x: 0, y: -1000, z: 0,
                    vx: 0, vy: 0, vz: 0,
                    life: 0, maxLife: 0
                });
            }
            scene.add(trailSystem);

            // 初始位置
            santaGroup.position.set(-250, 10, 0);
            scene.add(santaGroup);
        }

        function onWindowResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function createGround() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<500; i++) {
                pos.push(
                    (Math.random() - 0.5) * 1000,
                    -50 + (Math.random() * 10),
                    (Math.random() - 0.5) * 600
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xaaeeff,
                size: 2,
                transparent: true,
                opacity: 0.3
            });
            const ground = new THREE.Points(geo, mat);
            scene.add(ground);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 15 * delta;
                    positions[i-1] -= 5 * delta; 

                    if (positions[i] < -200) {
                        positions[i] = 200;
                        positions[i-1] = Math.random() * 2000 - 1000;
                        positions[i+1] = Math.random() * 2000 - 1000;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y = time * 0.02;
            }

            if (santaGroup) {
                santaGroup.position.x += 80 * delta;
                santaGroup.position.y = 10 + Math.sin(time * 2) * 5;
                santaGroup.rotation.z = Math.sin(time * 3) * 0.05;

                if (santaGroup.position.x > 250) {
                    santaGroup.position.x = -250;
                }
            }

            const runSpeed = 15; 
            const runAmp = 0.5;  
            reindeerLegs.forEach(legData => {
                legData.mesh.rotation.z = Math.sin(time * runSpeed + legData.phase) * runAmp;
            });

            if (trailSystem && santaGroup) {
                const positions = trailSystem.geometry.attributes.position.array;
                const data = trailSystem.userData.particles;
                
                trailSystem.userData.spawnTimer += delta;
                
                let spawnCount = 15;
                for(let k=0; k<data.length; k++) {
                    const p = data[k];
                    
                    if (p.life <= 0 && spawnCount > 0) {
                        const offsetX = (Math.random() - 0.5) * 10;
                        const offsetY = (Math.random() - 0.5) * 5;
                        const offsetZ = (Math.random() - 0.5) * 10;
                        
                        p.x = santaGroup.position.x - 15 + offsetX;
                        p.y = santaGroup.position.y + offsetY;
                        p.z = santaGroup.position.z + offsetZ;
                        
                        p.vx = -((Math.random() * 10) + 10);
                        p.vy = (Math.random() - 0.5) * 5;
                        p.vz = (Math.random() - 0.5) * 5;
                        
                        p.life = 1.0;
                        p.maxLife = 1.0;
                        
                        spawnCount--;
                    }
                    
                    if (p.life > 0) {
                        p.x += p.vx * delta;
                        p.y += p.vy * delta;
                        p.z += p.vz * delta;
                        p.life -= delta * 0.8; 
                        
                        positions[k*3] = p.x;
                        positions[k*3+1] = p.y;
                        positions[k*3+2] = p.z;
                    } else {
                        positions[k*3] = 0;
                        positions[k*3+1] = -5000;
                        positions[k*3+2] = 0;
                    }
                }
                trailSystem.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>